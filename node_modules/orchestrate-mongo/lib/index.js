var async = require('async');
var MongoWatch = require('mongo-watch');
var orchestrate = require('orchestrate');
var EventEmitter = require('events').EventEmitter;
var util = require('./util');

function syncEventToOrchestrate (db, emitter, event, done) {
  var is_done = false;
  function success (res) {
    if (!is_done) {
      is_done = true;
      emitter.emit('change', event);
      emitter.emit('change.success', event, res);
      done();
    }
  }

  function failure (err) {
    if (!is_done) {
      is_done = true;
      emitter.emit('change', event);
      emitter.emit('change.error', event, err);
      done();
    }
  }

  switch (event.method) {
    case 'put':
      db.put(event.collection, event.key, event.obj)
      .then(success)
      .fail(failure);
      break;
    case 'update':
      db.get(event.collection, event.key)
      .then(function (res) {
        var obj = res.body;
        var operator;

        for (operator in event.obj) {
          if (operator[0] !== '$') {
            obj[operator] = event.obj[operator];
          }
        }

        for (operator in event.obj) {
          if (operator in util.update_operators) {
            obj = util.update_operators[operator](obj, event.obj[operator]);
          } else if (operator[0] === '$') {
            failure(new Error("Unexpected update operator"));
            break;
          }
        }

        return db.put(event.collection, event.key, obj);
      })
      .fail(failure)
      .then(success);
      break;
    case 'delete':
      db.remove(event.collection, event.key, true)
      .then(success)
      .fail(failure);
      break;
    default:
      failure(new Error("Unexpected method"));
      break;
  }
}

var queue = async.queue(syncEventToOrchestrate);

function addEventToQueue (queue, emitter, event) {
  var data = event;
  var collection;
  var key;
  var method;
  var obj;

  // emit change.start events
  emitter.emit('change', event);
  emitter.emit('change.start', event);
  
  // determine collection
  collection = data.ns && data.ns.split('.')[1];
  if (['i', 'u', 'd'].indexOf(data.op) !== -1) {
    switch (data.op) {
      case 'i':
        method = 'put';
        key = data.o._id;
        obj = data.o;
        break;
      case 'u':
        method = 'update';
        key = data.o2._id;
        obj = data.o;
        break;
      case 'd':
        method = 'delete';
        key = data.o._id;
        break;
    }

    queue.unshift({
      collection: collection,
      key: key,
      method: method,
      obj: obj
    });
  } else {
    // event we don't care about
    console.log(data);
  }
}

function setOptions (options) {
  options = options || {};
  options.orchestrate = options.orchestrate || {};
  options.mongodb = options.mongodb || {};

  return {
    orchestrate: {
      api_key: options.orchestrate.api_key || process.env.ORCHESTRATE_API_KEY
    },
    mongodb: {
      port: options.mongodb.port || process.env.MONGODB_PORT || 27017,
      host: options.mongodb.host || process.env.MONGODB_HOST || 'localhost',
      dbOpts: options.mongodb.dbOpts || { w: 1 },
      format: options.mongodb.format || 'raw',
      convertObjectIDs: options.mongodb.convertObjectIDs || true,
      username: options.mongodb.username || process.env.MONGODB_USERNAME,
      password: options.mongodb.password || process.env.MONGODB_PASSWORD
    },
    database: options.mongodb.database || process.env.MONGODB_DATABASE,
    collection: options.mongodb.collection || process.env.MONGODB_COLLECTION
  };
}

function OrchestrateMongo (opts) {
  var options = setOptions(opts);
  var db = orchestrate(options.orchestrate.api_key);

  var emitter = new EventEmitter();

  var event_handler = syncEventToOrchestrate.bind(null, db, emitter);
  var queue = async.queue(event_handler, 1);
  queue.drain = emitter.emit.bind(emitter, 'drain');

  var watcher = new MongoWatch(options.mongodb);
  var db_watcher = watcher.watch([options.database, options.collection].join('.'), function (event) {
    addEventToQueue(queue, emitter, event);
  });

  // expose super secret attributes for testing
  // this is such a bad idea
  emitter.__queue = queue;
  emitter.__watcher = watcher;

  return emitter;
}

module.exports = OrchestrateMongo;